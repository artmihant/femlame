# Практикум по МКЕ - образец

В данном примере мы решаем задачу Ламе методом конечных элементов.

Общий скрипт запускается через main.py . Возможно вам нужно будет доустановить какие-то библиотеки.

Параметры задачи выглядят примерно так:


    config = {
        "geometry": {
            "radius_min":1,
            "radius_max":2,
        },
        "mesh":{
            "resolution":10,
        },
        "material":{
            "E":2*10**11,
            "Nu":0.25,
        },
        "bcs":{
            "pressure_inner":1.0,
            "pressure_outer":2.0
        }
    }

Здесь заданы внутренний и внешний радиус трубы, давление на внутренний и внешний радиус, параметры материала и характерное разрешение сетки (число элементов на внутренней дуге). Задача будет решена на четверти плоского среза трубы с гранусловиями первого рода на её радиальных сторонах и гранусловиями второго рода (давлением) на дуговых сторонах.

Первая часть программы , `GenLameMesh`, генерирует сетку (mesh) под задачу Ламе на основе данных из `config["geometry"]` и `config["mesh"]`.

Сетка выглядит как:

    mesh = {
        nodes: array(dtype=float, shape=(116,2))
        elems: array(dtype=int, shape=(189,3))
        edges: {
            inner: array(dtype=int, shape=(11))
            right: array(dtype=int, shape=(8))
            outer: array(dtype=int, shape=(18))
            left: array(dtype=int, shape=(9))
        }
    }

Здесь заданы координаты всех узлов сетки, поиндексно заданные элементы сетки (треугольники) и четыре грани сетки, опять же, заданные поиндексно по граничным узлам.

Сетку можно выгрузить в файл inp и рассмотреть с помощью mesh2inp

Дальше, с помощью GenLameTask мы сгенерируем задачу (task) с помощью `config["material"]` и `config["boundary_condition"]`. Получится:


    task = {
        nodes: array(dtype=float, shape=(116,2))
        elems: array(dtype=int, shape=(189,3))
        bcs: [
            {"nodes": [...], "type": "dirichlet", "value": 1},
            {"nodes": [...], "type": "neumann", "fix": 1, "value": 0},
            {"nodes": [...], "type": "dirichlet", "value": 0},
            {"nodes": [...], "type": "neumann", "fix": 0, "value": 0}
        ],
        material: {"E": 2*10**11, "Nu": 0.35}
    }

Мы видим здесь два типа гранусловий (bcs) - первого рода (neumann) и второго рода (dirichlet). 
Гранусловия Неймана в этой задаче - закрепленя по одной оси - оси x (0) или оси y (1).

Эту задачу мы отдадим решателю (solver) и получим от него результат в виде обьекта Solution (по сути - функции вычисления компонентов тензоров в точке).

Наконец, мы проверяем этот Solution посредством LameTest на достоверность в нескольких точках.

## TODO

В этой программе много несовершенств.

Solution возвращает вычисленную кусочно-линейную аппроксимацию. Было бы точнее использовать сплайны второго порядка.

LameTest просто складывает невязку по 11 точкам вдоль радиуса. Было бы точнее выбрать некое число случайных точек в заданной области и посчитать норму L0 (максимум по модулю) невязки. 

Так же нехудо бы проверить не только stress но и strain и displacement. Можно придумать и другие очевидные тесты, а так же попробовать выгрузить эту задачу в vtu. Тем, кто хочет это заняться, прикладываю к коду парсер vtk_reader. Правда, он на выгрузку, обратный парсер придется писать.

Решатель работает в однопоточном режиме. Можно попробовать распарралелить его.

Сетку программы можно просматривать но нельзя считывать из fc или того же inp. Для тех, кто хочет этим заняться, к коду приложен fc_reader - парсер fc.

Наконец, архитектура программы выстроена более-менее универсально в рамках выделенного набора задач; так что стоит испытать её, задав схожим образом другие задачи (не только Ламе на четвертькруге)
